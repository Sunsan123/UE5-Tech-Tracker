import { readFile, readdir, writeFile, mkdir } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import YAML from "yaml";
import { parseFrontMatter } from "../../../tools/pipeline/src/markdown.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "../../..");
const dataDir = path.join(repoRoot, "data");
const itemsDir = path.join(dataDir, "items");
const metaDir = path.join(dataDir, "meta");
const configDir = path.join(repoRoot, "config");
const outputDir = path.join(repoRoot, "apps/web/src/data");
const chunksDir = path.join(outputDir, "chunks");
const reportsDir = path.join(repoRoot, "reports");
const dailyReportPath = path.join(reportsDir, "daily", "index.json");
const logsPath = path.join(reportsDir, "logs", "index.json");

const readYaml = async (fileName) => {
  const content = await readFile(path.join(configDir, fileName), "utf8");
  return YAML.parse(content);
};

const readVersions = async () => {
  const content = await readFile(path.join(metaDir, "versions.json"), "utf8");
  return JSON.parse(content);
};

const readDailyReport = async () => {
  try {
    const content = await readFile(dailyReportPath, "utf8");
    return JSON.parse(content);
  } catch (error) {
    if (error.code === "ENOENT") {
      return { date: null, modules: [] };
    }
    throw error;
  }
};

const readBuildLogs = async () => {
  try {
    const content = await readFile(logsPath, "utf8");
    return JSON.parse(content);
  } catch (error) {
    if (error.code === "ENOENT") {
      return { builds: [] };
    }
    throw error;
  }
};

const extractFilePaths = (body) => {
  const matches = body.match(/Engine\/[\w\-/\.]+/g) ?? [];
  return Array.from(new Set(matches));
};

const computeCredibility = (sources = []) =>
  sources.some((source) => source.credibility === "high") ? "high" : "low";

const loadItems = async () => {
  const entries = await readdir(itemsDir, { withFileTypes: true });
  const items = [];

  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith(".md")) {
      continue;
    }
    const raw = await readFile(path.join(itemsDir, entry.name), "utf8");
    const { frontMatter, body } = parseFrontMatter(raw);
    if (!frontMatter) {
      continue;
    }

    items.push({
      ...frontMatter,
      body,
      file_paths: extractFilePaths(body),
      credibility: computeCredibility(frontMatter.sources ?? []),
    });
  }

  return items;
};

const buildScore = (item, scoringConfig) => {
  const reasons = [];
  let score = 0;

  const changeWeight = scoringConfig?.change_type?.[item.change_type] ?? 1;
  score += changeWeight;
  reasons.push(`change_type:${item.change_type}+${changeWeight}`);

  const highSources = (item.sources ?? []).filter(
    (source) => source.credibility === "high",
  ).length;
  if (highSources > 0) {
    const highWeight = (scoringConfig?.high_source ?? 0) * highSources;
    score += highWeight;
    reasons.push(`high_sources:${highSources}+${highWeight}`);
  }

  const sourceWeight = (scoringConfig?.source_count ?? 0) * (item.sources ?? []).length;
  if (sourceWeight) {
    score += sourceWeight;
    reasons.push(`sources:${item.sources?.length ?? 0}+${sourceWeight}`);
  }

  if (item.has_conflict) {
    score += scoringConfig?.conflict ?? 0;
    reasons.push(`conflict+${scoringConfig?.conflict ?? 0}`);
  }

  return { score, reasons };
};

const buildIndex = async () => {
  const scoringConfig = await readYaml("scoring.yaml");
  const items = await loadItems();

  const indexItems = items.map((item) => {
    const { score, reasons } = buildScore(item, scoringConfig?.scoring ?? {});
    const summarySource = item.sources?.[0];
    return {
      id: item.id,
      title: item.title,
      title_zh: item.title,
      title_en: item.title,
      version: item.version,
      published_at: item.published_at,
      module_system: item.module_system,
      change_type: item.change_type,
      tags: item.tags,
      summary_zh: summarySource?.excerpt_zh ?? "",
      summary_en: summarySource?.excerpt_en ?? "",
      credibility: item.credibility,
      p1_score: score,
      p1_reasons: reasons,
    };
  });

  return { indexItems, items };
};

const writeIndex = async (indexItems) => {
  const output = `// This file is generated by scripts/generate-data.mjs. Do not edit directly.\n\nexport const indexItems = ${JSON.stringify(
    indexItems,
    null,
    2,
  )} as const;\n\nexport type IndexItem = (typeof indexItems)[number];\n`;
  const sizeMb = Buffer.byteLength(output, "utf8") / (1024 * 1024);
  if (sizeMb > 50) {
    console.warn(`Index base size ${sizeMb.toFixed(2)}MB exceeds 50MB.`);
  }
  await writeFile(path.join(outputDir, "index-base.ts"), output, "utf8");
};

const writeChunks = async (items) => {
  await mkdir(chunksDir, { recursive: true });
  const chunkMap = new Map();

  for (const item of items) {
    const modules = Array.isArray(item.module_system)
      ? item.module_system
      : [item.module_system];
    for (const moduleId of modules) {
      if (!chunkMap.has(moduleId)) {
        chunkMap.set(moduleId, []);
      }
      chunkMap.get(moduleId).push({
        id: item.id,
        title: item.title,
        title_zh: item.title,
        title_en: item.title,
        version: item.version,
        published_at: item.published_at,
        module_system: item.module_system,
        module_code: item.module_code,
        change_type: item.change_type,
        tags: item.tags,
        sources: item.sources,
        github_refs: item.github_refs,
        thumbs: item.thumbs ?? [],
        ai: item.ai,
        benefits: item.benefits,
        risks: item.risks,
        file_paths: item.file_paths ?? [],
        credibility: item.credibility,
      });
    }
  }

  for (const [moduleId, moduleItems] of chunkMap.entries()) {
    const output = `// This file is generated by scripts/generate-data.mjs. Do not edit directly.\n\nconst moduleItems = ${JSON.stringify(
      moduleItems,
      null,
      2,
    )} as const;\n\nexport type ModuleItem = (typeof moduleItems)[number];\n\nexport default moduleItems;\n`;
    await writeFile(path.join(chunksDir, `chunk_${moduleId}.ts`), output, "utf8");
  }
};

const writeVersions = async (versionsData) => {
  const output = `// This file is generated by scripts/generate-data.mjs. Do not edit directly.\n\nexport const versions = ${JSON.stringify(
    versionsData.versions ?? [],
    null,
    2,
  )} as const;\n\nexport const latestMajor = ${JSON.stringify(
    versionsData.latest_major ?? null,
  )} as const;\n\nexport type VersionMeta = (typeof versions)[number];\n`;

  await writeFile(path.join(outputDir, "versions.ts"), output, "utf8");
};

const writeDailyReport = async (dailyReport) => {
  const serialized = JSON.stringify(dailyReport ?? { date: null, modules: [] }, null, 2);
  const output = `// This file is generated by scripts/generate-data.mjs. Do not edit directly.\n\nexport type DailyReportItem = {\n  id: string;\n  title: string;\n  version: string;\n  published_at?: string | null;\n  p1_score?: number;\n};\n\nexport type DailyReportModule = {\n  id: string;\n  items: DailyReportItem[];\n};\n\nexport type DailyReport = {\n  date: string | null;\n  modules: DailyReportModule[];\n};\n\nexport const dailyReport: DailyReport = ${serialized};\n`;
  await writeFile(path.join(outputDir, "daily-reports.ts"), output, "utf8");
};

const writeBuildLogs = async (buildLogs) => {
  const serialized = JSON.stringify(buildLogs?.builds ?? [], null, 2);
  const output = `// This file is generated by scripts/generate-data.mjs. Do not edit directly.\n\nexport type BuildLogStep = {\n  name: string;\n  status: \"success\" | \"failed\";\n  error_samples?: string[];\n  truncated?: boolean;\n  quota_exhausted?: boolean;\n};\n\nexport type BuildLog = {\n  id: string;\n  started_at: string;\n  finished_at: string | null;\n  status: \"running\" | \"success\" | \"partial\" | \"failed\";\n  incomplete_data: boolean;\n  truncated: boolean;\n  quota_exhausted: boolean;\n  steps: BuildLogStep[];\n  error_samples: string[];\n};\n\nexport const buildLogs: BuildLog[] = ${serialized};\n`;
  await writeFile(path.join(outputDir, "build-logs.ts"), output, "utf8");
};

const main = async () => {
  const versionsData = await readVersions();
  const dailyReport = await readDailyReport();
  const buildLogs = await readBuildLogs();
  const { indexItems, items } = await buildIndex();

  await mkdir(outputDir, { recursive: true });
  await writeVersions(versionsData);
  await writeIndex(indexItems);
  await writeChunks(items);
  await writeDailyReport(dailyReport);
  await writeBuildLogs(buildLogs);

  console.log("Generated frontend data modules.");
};

await main();
